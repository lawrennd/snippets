\ifndef{probabilisticPcaModel}
\define{probabilisticPcaModel}

\editme

\subsection{The Probabilistic PCA Model}

\notes{For our notation, we express the $i$th data point's position in the
underlying latent space by the vector $\latentVector_{i, :}$. The
relationship between the latent space and the data space in the form
of a linear mapping,
\[
\dataVector_{i, :} = \mappingMatrix \latentVector_{i, :} + \meanVector
+ \noiseVector_{i, :}
\]
where $\mappingMatrix \in \Re^{\dataDim,\latentDim}$ is a mapping
matrix which encodes the relationship between the latent space and the
data space. The vector $\noiseVector$ represents the corrupting
noise. We will assume the noise is independently sampled from a
Gaussian density,
\[
\noiseVector_{i,:} \sim \gaussianSamp{0}{\dataStd^2\eye},
\]
where $\dataStd$ is the standard deviation of the corrupting noise.}

\notes{Linear dimensionality reduction can be thought of as finding a lower
dimensional plane embedded in a higher dimensional space. The plane is
described by the matrix $\mappingMatrix$. The direction of the vectors
in this matrix define the orientation of the
plane. The figure below shows how this works when
the latent space is two dimensional and the data space is three
dimensional.}

\setupplotcode{import numpy as np
import matplotlib.pyplot as plt
from mpl_toolkits.mplot3d import Axes3D
import mlai
import mlai.plot as plot}

\plotcode{fig = plt.figure(figsize=(15, 5))

# Parameters
alpha = 1
number_across = 10
num_samples = 3

# Create 2D grid in latent space
x1 = np.linspace(-1, 1, number_across)
x2 = x1
X1, X2 = np.meshgrid(x1, x2)
X = np.column_stack([X1.ravel(), X2.ravel()])

# Generate random mapping matrix
np.random.seed(24)  # For reproducibility
W = np.random.randn(num_samples, 2) * np.sqrt(alpha)

# Map to 3D data space
F = X @ W.T

# Plot 1: 2D latent space
ax1 = fig.add_subplot(1, 3, 1)
ax1.hold(True)

# Plot grid lines in x1 direction
for i in range(number_across):
    start_idx = i * number_across
    end_idx = (i + 1) * number_across
    ax1.plot(X[start_idx:end_idx, 0], X[start_idx:end_idx, 1], 'r-', linewidth=1)

# Plot grid lines in x2 direction (transpose and plot)
X1_T = X1.T
X2_T = X2.T
X_T = np.column_stack([X1_T.ravel(), X2_T.ravel()])
for i in range(number_across):
    start_idx = i * number_across
    end_idx = (i + 1) * number_across
    ax1.plot(X_T[start_idx:end_idx, 0], X_T[start_idx:end_idx, 1], 'r-', linewidth=1)

# Add axes
ax1.plot([-1.25, -1.25], [-1.25, 0.25], 'k-', linewidth=1)
ax1.plot([-1.25, 0.25], [-1.25, -1.25], 'k-', linewidth=1)

ax1.set_xlabel('$\\latentScalar_1$', fontsize=12)
ax1.set_ylabel('$\\latentScalar_2$', fontsize=12)
ax1.set_title('$\\latentMatrix$', fontsize=14)
ax1.set_aspect('equal')
ax1.axis('off')

# Plot 2: 3D data space
ax2 = fig.add_subplot(1, 3, 3, projection='3d')

# Plot grid lines in 3D
for i in range(number_across):
    start_idx = i * number_across
    end_idx = (i + 1) * number_across
    ax2.plot(F[start_idx:end_idx, 0], F[start_idx:end_idx, 1], F[start_idx:end_idx, 2], 'r-', linewidth=1)

# Plot grid lines in opposite direction
F1_reshaped = F[:, 0].reshape(number_across, number_across).T
F2_reshaped = F[:, 1].reshape(number_across, number_across).T
F3_reshaped = F[:, 2].reshape(number_across, number_across).T
F_T = np.column_stack([F1_reshaped.ravel(), F2_reshaped.ravel(), F3_reshaped.ravel()])

for i in range(number_across):
    start_idx = i * number_across
    end_idx = (i + 1) * number_across
    ax2.plot(F_T[start_idx:end_idx, 0], F_T[start_idx:end_idx, 1], F_T[start_idx:end_idx, 2], 'r-', linewidth=1)

# Add 3D axes
ax2.plot([-1.25, -1.25], [-1.25, 0.25], [-1.25, -1.25], 'k-', linewidth=1)
ax2.plot([-1.25, 0.25], [-1.25, -1.25], [-1.25, -1.25], 'k-', linewidth=1)
ax2.plot([-1.25, -1.25], [-1.25, -1.25], [-1.25, 0.25], 'k-', linewidth=1)

# Add axis labels
ax2.text(-0.5, -1.25, -1.25, '$\\dataScalar_1$', fontsize=10)
ax2.text(-1.25, -0.5, -1.25, '$\\dataScalar_2$', fontsize=10)
ax2.text(-1.25, -1.25, -0.5, '$\\dataScalar_3$', fontsize=10)

ax2.set_title('$\\dataMatrix$', fontsize=14)
ax2.axis('off')

# Add transformation arrow and equation
ax3 = fig.add_subplot(1, 3, 2)
ax3.set_xlim(0, 1)
ax3.set_ylim(0, 1)
ax3.axis('off')
ax3.text(0.5, 0.55, '$\\dataScalar_j = \\mappingFunction_j(\\latentVector)$', 
         fontsize=14, ha='center', va='center')
ax3.text(0.5, 0.45, '$\\longrightarrow$', fontsize=20, ha='center', va='center')

plt.tight_layout()

mlai.write_figure('linear-mapping-3d-plot.svg', directory='\\writeDiagramsDir/dimred/')}

\figure{\includediagram{\diagramsDir/dimred/linear-mapping-3d-plot}{80%}}{Mapping a two dimensional plane to a higher dimensional
space in a linear way. Data are generated by corrupting points on
the plane with noise.}{mapping2to3linear}

\endif
